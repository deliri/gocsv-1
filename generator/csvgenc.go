package main

import (
	"os"
	"encoding/csv"
	"golang.org/x/text/transform"
	"golang.org/x/text/encoding/simplifiedchinese"
	"errors"
	"fmt"
	"strings"
	"log"
	"path/filepath"
	"flag"
	"io/ioutil"
	"path"
"unicode"
)


var csvpath = flag.String("csvpath", "", "exmaple: xxx/data/demo.csv or dir: xxx/data")
var outpath = flag.String("outpath", "", "exmaple: xxx/data/demo.go or dir: xxx/data")
var utf8 = flag.Bool("utf8", false, "utf8 is: true|false")

func main() {
	//abs, err := filepath.Abs("./../")
	//log.Printf(filepath.Base(abs))
	flag.Parse()
	if *csvpath == ""{
		flag.Usage()
		return
	}
	fileInfo, err := os.Stat(*csvpath)
	if err != nil {
		log.Panic(err)
		return
	}
	if fileInfo.IsDir(){
		infos, err := ioutil.ReadDir(*csvpath)
		if err != nil {
			log.Panic(err)
			return
		}
		if *outpath == ""{
			*outpath = *csvpath
		}
		for _, info := range infos{
			ext := filepath.Ext(info.Name())
			if ext != ".csv"{
				continue
			}
			gofile := strings.Replace(info.Name(), ".csv", ".go", -1)
			err := write(path.Join(*csvpath, info.Name()), path.Join(*outpath, gofile), *utf8)
			if err != nil {
				log.Printf("generator file: %v error: %v", info.Name(), err)
				continue
			}
		}

	} else{
		err := write(*csvpath, *outpath, *utf8)
		if err != nil {
			log.Panic(err)
			return
		}
	}
	log.Print("generator done!")

}

//Goods goods struct for csv
type Goods struct {
	ID   int `csv:"id"`        //id => ID
	Name string                // name => Name (default, first letter lowercase)
	Cost float32 `csv:"price"` // rename price => cost
}

func write(csvfile string, outfile string, isUtf8 bool) error {
	//open file
	fi, err := os.Open(csvfile)
	if err != nil {
		return err
	}
	defer fi.Close()
	//get reader
	var reader *csv.Reader
	if isUtf8 {
		reader = csv.NewReader(fi)
	} else {
		//transform gbk to utf8
		r := transform.NewReader(fi, simplifiedchinese.GBK.NewDecoder())
		reader = csv.NewReader(r)
	}

	lines, err := reader.ReadAll()
	if err != nil {
		return errors.New(fmt.Sprintf("read error: %v", err))
	}
	lineNum := len(lines)
	if (lineNum < 3) {
		return errors.New(fmt.Sprintf("Csv %v is invalid"))
	}
	names, fields, kinds := lines[0], lines[1], lines[2]
	fieldNum := len(names)
	filename := filename(csvfile)

	if outfile == ""{
		outfile = strings.Replace(csvfile, ".csv", ".go", -1)
	}
	//packname
	packname := ""
	outAbs, _ := filepath.Abs(outfile)
	packname = filepath.Base(filepath.Dir(outAbs))
	if packname == ""{
		csvAbs, _ := filepath.Abs(csvfile)
		packname = filepath.Base(filepath.Dir(csvAbs))
	}


	code := fmt.Sprintf("// Code generated by github.com/foolin/gocsv.\n// source: %v\n// DO NOT EDIT! \n\npackage %v\n\ntype %v struct {\n", filepath.Base(csvfile), packname, upper(filename))
	for j := 0; j < fieldNum; j++ {
		name := names[j]
		field := fields[j]
		kind := kinds[j]
		if kind == "float" {
			kind = "float32"
		}
		code = code + fmt.Sprintf("\t%v %v `csv:\"%v\"` //%v\n", upper(field), kind, field, name)
	}
	code = code + "}\n"

	//mkdir
	err = os.MkdirAll(path.Dir(outAbs), 0755)
	if err != nil {
		return err
	}

	//write file
	err = ioutil.WriteFile(outfile, []byte(code), 0755)
	if err != nil {
		return err
	}
	log.Printf("write file: %v", outfile)
	return nil
}

func upper(str string) string {
	if str == ""{
		return str
	}
	ret := make([]rune, 0)
	isNeedUpper  := true	//首字母大写
	for _, c := range str{
		//log.Printf("%#v\n", c)
		if c == '_'{
			isNeedUpper = true	//下划线大写
			continue
		}
		if isNeedUpper{
			ret = append(ret, unicode.ToUpper(c))
		}else{
			ret = append(ret, c)
		}
		isNeedUpper = false
	}
	return string(ret)
}

func filename(filename string) string {
	name := filepath.Base(filename)
	return strings.TrimSuffix(name, filepath.Ext(filename))
}